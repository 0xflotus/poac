> Note: ここでは簡潔に述べます。
[conan との違い](../architecture/differences-to-conan.md) で、
詳細で技術的な目線から poac の存在意義に関して話します。


TODO: これを参考にする！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
https://doc.rust-lang.org/cargo/guide/why-cargo-exists.html



## なぜ poac を開発したのか

我々は長らく，`g++ ... 大量のオプション`や，cmakeとmakeの謂わばモダンでない文法を扱う必要があった．
`./configure && make && make install`なども(http://www.itmedia.co.jp/help/tips/linux/l0302.html)
(勿論，ninjaやkati，buck，bazelなどがあるが，論点はそこではない)
多くのツールが，使いやすく刷新されてきたにも関わらず，C++のツールに関しては未だに
直感的でないインタフェースを兼ね備えている．(ここで，直感的とは，その時代のよく使用されるツールのインタフェース
と似ており，かつ，その名称から動作が容易に推測可能であることを指す．)
さらに，多くのライブラリは，make installで `/usr/local` にインストールされる．
これは，即ちグローバルにインストールされ，プロジェクトごとに切り分けができていないことになる．
それは，後々ちょっとしたコードを公開するにも，READMEにインストールする必要があると明記する必要がある．
そのため，使用者が一々手動でダウンロードする必要がある．依存が多ければ多いほど，それ用に，`./configure && make && make install`だの，
`cmake .. && make && make install`だの，`apt-get install ...`だの，する必要がある．
しかし，長く開発していたり，別のプロジェクトも同一のPCで開発を行なっていると，
どのプロジェクトがどのライブラリに依存していたのか分からなくなる．
そうすると，一度クリーンなPCを用意し，コンパイルを試し，エラーが出るヘッダーがあればそれをインストールし，メモする．
もしくは，そういったことは無視して，それを使用するユーザーが使用する際に同じことを試させてみる？
勿論初めからどのライブラリを使用しているのかをREADMEに逐一メモしていけばそんなことは起きない．(が，面倒だし人的ミスが起きることは目に見えている)

RustのCargoもビルドシステム兼パッケージマネージャである．
ソースファイルのinclude順よりも，予め固定化された依存関係を読む方が格段に楽だ．
依存関係は，どちらも必要である．パッケージマネージャもライブラリをインストールするのに必要で，
ビルドシステムもビルドの順序を決定するのに必要である．
依存関係は？トップレベルの依存関係を，大概，yamlやtomlなどのファイルに記述する．
そこから解決できれば良い．

それをツールの設定ファイルとして記述されると，恐ろしく管理が楽になる．
特に他の言語のパッケージマネージャを使用してきた方ならその良さを体感できるだろう．
そろそろC++の開発者及びC++をこれから学ぼうと思っている初学者はこういったことから解放されようではないか．

C++には優れた資産が多くある．
[tensorflow](https://github.com/tensorflow/tensorflow)だってsession周りがC++で実装されている．
Ethereumの[solidity](https://github.com/ethereum/solidity)だってC++で実装されている．
多くの技術・技術の核に，C++は用いられている．

まだまだC++現役だ．いやそうじゃなく，C++がこれからも必要不可欠である．
